---
layout: post
title:  "컴퓨터 구조"
author: "doremin"
tags: [Elements Of Compting Systems]
---

## 컴퓨터 구조

### 내장식 프로그램
컴퓨터의 유연성은 내장식 프로그램(Stored Program)이라는 개념에서 비롯한다. 기본적인 아이디어는 컴퓨터는 정해진 명령어 집합들을 실행하는 고정된 하드웨어 플랫폼이라는 아이디어에 기반한다. 동시에 컴퓨터가 실행하는 명령어들은 기본 블록이 되어 무한히 복잡한 프로그램으로 조합된다. 이 프로그램들은 하드웨어에 내장되지 않고, 프로그램의 코드가 컴퓨터 메모리상에 데이터처럼 저장되고 연산된다.

### 폰 노이만 구조
내장식 프로그램 개념은 추상적인 컴퓨터 모델이나 실제 모델의 핵심 요소로서, 이 모델 중에 가장 주목할 만한 것은 **보편 튜링 기계**(Universal Turing Machine, 1936)와 **폰 노이만 기계**(Von Neumann Machine, 1945)다. 튜링 기계는 믿기 어려울 정도로 간단한 추상적 컴퓨터 모델로, 주로 컴퓨터 시스템의 논리적 기초를 분석하는 데 쓰인다. 폰 노이만 기계는 현대의 거의 모든 컴퓨터 플랫폼의 개념적 설계도이자 실제 구조이기도 하다.
![VonNeumannMachine](/assets/images/2021-01-13/2021-01-13-5.png)

중앙 처리 장치(CPU)를 기반으로 하며, 이 장치는 메모리 장치와 통신하고, 입력 장치에서 데이터를 받고, 출력 장치에 데이터를 보내는 일을 한다. 이 구조의 중심에 내장식 프로그램 개념이 있다.

### 메모리
폰 노이만 기계의 메모리는 데이터와 명령어, 두 종류의 정보를 저장한다. 이 두 정보는 보통 다르게 취급되며, 어떤 컴퓨터에서는 메모리 장치를 분리해서 따로 저장하기도 한다.

##### 데이터 메모리
고수준 프로그램은 변수, 배열, 객체같은추상적 개념들을 다룬다. 이런 추상적 데이터들을 기계어로 번역하면 2진 숫자열로 바뀌어 데이터 메모리에 저장된다. 주소를 통해 데이터 메모리에서 한 단어를 선택하면, 그 단어에 읽기나 쓰기가 가능하다.

##### 명령어 메모리
고수준 명령들을 기계어로 번역하면, 각각 2진수 기계어 명령어를 뜻하는 단어들이 된다. 이 명령어들은 컴퓨터의 명령어 메모리(Instruction Memory)에 저장된다. 컴퓨터 연산의 각 단계마다 CPU는 명령어 메모리에서 단어 하나를 인출(Fetch)하고, 해석한 후에, 정해진 명령을 수행하고, 다음에 실행할 명령어가 무엇인지 찾아낸다.

### 중앙 처리 장치
컴퓨터 아키텍처의 가장 핵심인 중앙 처리 장치(CPU)는 불러온 프로그램의 명령어를 실행하는 일을 담당한다. CPU는 이 명령어들을 통해 다양한 계산을 수행하고, 메모리에 값을 읽거나 쓰고, 조건에 따라 다른 명령어로 점프한다. CPU가 이런 작업을 수행하는 데는 세 가지 주요 하드웨어가 관여한다. 산술 논리 연산 장치(ALU), 레지스터(Register), 제어 장치(Control Unit)가 그것이다.

##### 산술 논리 연산 장치(ALU)
ALU는 컴퓨터에서 지원하는 모든 저수준 산술 연산 및 논리 연산을 수행하는 장치다. 예를 들어 일반적인 ALU는 두 값을 더하거나, 어떤 숫자가 양수인지 확인하거나, 데이터 단어의 비트를 조작하는 등의 일을 할 수 있다.

##### 레지스터(Register)
CPU는 간단한 계산을 빠르게 수행하도록 설계된다. 계산 성능을 올리려렴ㄴ 이런 계산의 결과를 매번 메모리에 로드하고 저장하기보다는, CPU근처에 저장할 필요가 있다. 이런 이유로 모든 CPU는 단어 하나를 저장할 수 있는 고속 레지스터들을 약간씩 갖추고 있다.

##### 제어 장치(Control Unit)
컴퓨터 명령어는 보통 폭이 16, 32, 또는 64 비트인 2진 코드로 표현된다. 이런 명령어 하나가 실행되려면, 명령어를 해석하는 다양한 하드웨어 장치가 명령을 어떻게 실행해야 하는지 정보를 알아내고 각각에 전달해야 한다. 명령어 해석은 제어 장치에서 이루어지는데, 동시에 이 장치는 어떤 명령어를 인출하고 다음에 실행해야 하는지 알아내는 역할도 한다.

명령어가 실행될 때는 ALU에서 어떤 값을 계산하고, 내부 레지스터를 조작하고, 메모리에서 단어 하나를 읽고, 메모리에 단어 하나를 쓰는 작업들 중 하나 이상을 하게 된다. CPU는 이 작업을 실행하는 과정에서 다음에 인출하고 실행할 명령어를 찾는 작업도 한다.

### 레지스터
메모리 접근은 느린 작업이다. CPU가 메모리 주소 j의 내용을 가져오라는 지시를 받으면, 다음과 같은 과정이 진행된다.
1. j가 CPU에서 RAM으로 전달된다.
2. RAM의 직접 접근 논리에 따라 주소가 j인 메모리 레지스터가 선택된다.
3. RAM[j]의 내용이 CPU로 다시 전달된다. 

레지스터는 데이터 추출 및 저장 기능은 RAM과 동일하지만, 데이터가 왔다갔다하고 메모리를 탐색하는데 비용을 들이지는 않는다. 그 이유는 
1. 레지스터는 CPU 칩 내부에 물리적으로 위치하므로 거의 바로 접근이 가능하다
2. 메모리 셀은 거의 수백만 개가 있지만 보통 레지스터는 소수만 있기 때문이다. 따라서 조작할 레지스터를 지정하는 데 몇 개의 비트만 필요하므로, 명령어 길이도 더 짧게 된다.

CPU들은 용도에 따라서 여러 종류의 레지스터를 각각 다른 개수만큼 사용한다. 어떤 컴퓨터 아키텍처에서는 다음과 같이 레지스터가 하나 이상의 기능을 수행한다.

데이터 레지스터(Data Register)
    : 이 레지스터들은 CPU의 단기 기억 메모리 기능을 한다. 예를 들어 (a-b)*c 값을 계산한다고 할 때, 먼저 (a-b)의 값을 계산하고 기억할 필요가 있다. 이 중간 값을 메모리에 임시로 저장할 수 있긴 하지만, CPU 내부에 저장하는 편이 더 낫기 때문에 그 용도로 데이터 레지스터를 둔다.

주소 지정 레지스터(Addressing Register)
    : CPU는 데이터를 읽고 쓰기 위해 계속해서 메모리에 접근해야 한다. 그리고 이 연산마다 접근할 메모리 주소를 지정해야 한다. 어떤 경우에는 이 주소가 현재 명령어에 포함되기도 하고, 또 다른 경우에는 예전 명령어의 실행 결과를 이용하기도 한다. 후자의 경우에는 주소가 될 값을 저장해야 하는데, 바로 주소 지정 레지스터가 그 역할을 한다.

프로그램 계수기 레지스터(Program Counter Register)
    : 프로그램을 실행할 때, CPU는 명령어 메모리에서 인출해야 할 다음 명령어의 주소를 항상 알고 있어야 한다. 이 주소는 프로그램 계수기(Program Counter)로 불리는 레지스터가 저장한다. 그리고 PC의 값은 명령어 메모리에서 인출할 명령어의 주소로 쓰인다. 따라서 jump 명령어는 PC의 값을 바꾸는 명령어이다.

### 입력과 출력
컴퓨터는 다양한 I/O장치를 통해 외부환경과 통신한다. 하지만 여러 입출력 장치들을 모두 분해해서 이해할 필요는 없다. 그 이유로
1. 이런 장치들을 이해하려면 개별적인 기술 지식이 필요하다.
2. 이러한 이유로 컴퓨터 과학자들이 입출력 장치들을 컴퓨터에서 완전히 똑같이 처리할 수 있는 기업들을 고안했기 때문이다. 이 기법중에 가장 간단한 것은 메모리 매핑 I/O(memory-mapped I/O)이다.

기본 아이디어는 I/O장치를 에뮬레이션해서, CPU에게 그 장치를 마치 일반적인 메모리 세그먼트처럼 보이도록 하는 것이다. 말하자면 각 I/O 장치마다 메모리 내에 전용 영역이 할당되어 메모리 맵 역할을 하게 된다. 입력 장치의 경우에 메모리 맵은 지속적으로 장치의 물리적 상태를 반영(reflect)하도록 되어 있으며, 출력 장치의 경우에는 지속적으로 장치의 물리적 상태를 구동(drive)하도록 만들어진다. 외부에서 어떤 이벤트가 입력 장치에 영향을 주면, 그 장치의 메모리 맵에 특정 값들이 기록된다. 마찬가지로, 어떤 출력 장치를 조작하고 싶을 때는, 그 장치의 메모리 맵에 특정 값들을 기록한다. 따라서 하드웨어 측면에서 I/O 장치들은 메모리 장치와 유사한 인터페이스를 제공해야 한다. 소프트웨어 관점으로는 각 I/O 장치에 통신 규약을 정의해서 프로그램이 올바르게 접근할 수 있도록 해야 한다.

메모리 매핑 I/O 아키텍처는 매우 중요하다. 컴퓨터와 통신하거나, 앞으로 통신할 I/O 장치들의 개수, 특성, 제품 종류와 전적으로 무관하게 CPU와 전체 플랫폼을 설계할 수 있기 때문이다. 우리는 새로운 I/O 장치를 컴퓨터에 연결하고 싶을 때마다 그저 그 장치를 새로운 메모리 맵에 할당하고 시작 주소를 메모해두기만 하면 된다(보통 운영체제가 이런 일을 담당한다). 그 다음부터는 어떤 프로그램에서도 메모리의 비트를 바꾸는 것만으로 이 I/O 장치를 조작할 수 있다.