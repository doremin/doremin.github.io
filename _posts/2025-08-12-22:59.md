---
layout: post
title: "Swift Concurrency의 hop 타이밍"
author: "doremin"
tags: [Swift]
published: false
---

# Swift Concurrency의 hop 타이밍

## TL;DR

-	hop = executor 전환
→ 함수/클로저 진입 시점, 또는 await 이후 재개 시점에 발생

-	await 이후 동작 요약
1. await → 현재 task suspend
2. 호출한 함수 완료 → generic executor에 suspended task를 enqueue
3. 재개된 함수/클로저에서 hop 수행 → 격리 보장

-	중요 포인트
	- Task가 resume될 때 런타임은 generic에 태움
	-	컴파일러가 prolog에 hop 삽입해 actor 격리를 보장
	-	불필요한 hop은 SIL optimizer가 제거 가능

---

## 1) hop이란 무엇인가 (개념)

**hop**은 **실행기 전환(executor hop)** 의 줄임말입니다.  
Swift Concurrency에서 Executor는 코드가 실행되는 컨텍스트(예: MainActor = 메인 executor, 특정 Actor = 전용 executor)를 의미합니다.

- **목적**: Actor의 **격리 규칙**을 지키고, MainActor 보장/데이터 경쟁 방지를 위해 필요합니다.
- **형태(SIL)**: `hop_to_executor %executor` 명령으로 관찰됩니다.
- **효과**: 이후 코드가 해당 Executor에서 실행되도록 스케줄링됩니다.

---

## 2) 예제

### Swift 코드

```swift
func foo() async {
    await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
        continuation.resume(returning: ())
    }
}

func bar() {
    Task { @MainActor in
        await foo()
    }
}
```

### SIL 코드

```swift
// foo()
// Isolation: unspecified
sil hidden [ossa] @$s1a3fooyyYaF : $@convention(thin) @async () -> () {
bb0:
  %0 = enum $Optional<Builtin.Executor>, #Optional.none!enumelt // users: %8, %1
  hop_to_executor %0 : $Optional<Builtin.Executor> // id: %1
  ...
  %7 = apply %6<()>(%2, %3, %5) : $@convention(thin) @async <τ_0_0> (@sil_isolated @guaranteed Optional<any Actor>, @guaranteed @noescape @callee_guaranteed @substituted <τ_0_0> (UnsafeContinuation<τ_0_0, Never>) -> () for <τ_0_0>) -> @sil_sending @out τ_0_0
  hop_to_executor %0 : $Optional<Builtin.Executor> // id: %8
  ...
} // end sil function '$s1a3fooyyYaF'

// closure #1 in bar()
// Isolation: global_actor. type: MainActor
sil private [ossa] @$s1a3baryyFyyYacfU_ : $@convention(thin) @Sendable @async @substituted <τ_0_0> (@guaranteed Optional<any Actor>) -> @out τ_0_0 for <()> {
// %0 "$return_value"
bb0(%0 : $*(), %1 : @guaranteed $Optional<any Actor>):
  %2 = metatype $@thick MainActor.Type            // user: %4
  // function_ref static MainActor.shared.getter
  %3 = function_ref @$sScM6sharedScMvgZ : $@convention(method) (@thick MainActor.Type) -> @owned MainActor // user: %4
  %4 = apply %3(%2) : $@convention(method) (@thick MainActor.Type) -> @owned MainActor // users: %11, %5
  %5 = begin_borrow %4 : $MainActor               // users: %10, %9, %6
  hop_to_executor %5 : $MainActor                 // id: %6
  // function_ref foo()
  %7 = function_ref @$s1a3fooyyYaF : $@convention(thin) @async () -> () // user: %8
  %8 = apply %7() : $@convention(thin) @async () -> ()
  hop_to_executor %5 : $MainActor                 // id: %9
  ...
} // end sil function '$s1a3baryyFyyYacfU_'
```

## 3) 컴파일러가 hop을 넣는 시점

컴파일러는 함수/클로저의 격리를 보고 진입 prolog에서 hop 필요 여부를 결정합니다.
- Actor 격리 + async → 진입부에서 기대 실행기로 hop 삽입
- await이후 resume될 때 다시 원래의 executor로 hop

즉 actor isolation의 책임은 callee에게 있습니다.

## 4) await이후 Task가 resume될 때 
await을 만나면 현재 task는 suspended상태가 되고, waiting queue로 진입하게 됩니다.
기다리는 함수가 끝나면 task가 waiting queue에서 dequeue되어 resume 하는데, 이때 원래의 격리에 맞춰서 resume 되는게 아니라 generic executor에 enqueue되게 됩니다.

[Task.cpp](https://github.com/swiftlang/swift/blob/main/stdlib/public/Concurrency/Task.cpp#L235-L316)

```cpp
void AsyncTask::completeFuture(AsyncContext *context) {
  ...
  // Schedule every waiting task on the executor.
  auto waitingTask = queueHead.getTask();
  ...
  while (waitingTask) {
    ...
    concurrency::trace::task_resume(waitingTask);

    // Enqueue the waiter on the global executor.
    // TODO: allow waiters to fill in a suggested executor
    waitingTask->flagAsAndEnqueueOnExecutor(SerialExecutorRef::generic());

    waitingTask = nextWaitingTask;
  }
}
```
> 결론: await 이후 처음 깨어나는 지점은 generic executor일 수 있습니다.

**그럼 Actor 격리는 어떻게?**

바로 다음 단계인 함수/클로저 재진입 단계에서 **필요하면 hop_to_executor**를 삽입해 격리를 맞춥니다.
즉, 런타임이 generic에 태우고 → 컴파일러가 hop으로 정렬하는 모델입니다. (주석을 보면 추후에는 수정될 여지가 있어보입니다.)