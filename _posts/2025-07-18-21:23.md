---
layout: post
title: Swift ARC Deep Dive
author: "doremin"
tags: [Swift]
---

# Swift ARC Deep Dive

## 1. 계기
이전에 ARC관련 코드가 컴파일 단계에서 어떻게 삽입되는지 확인하기 위해서 SIL로 컴파일 했던 글을 작성했었어요. 그런데 막상 SIL로 컴파일된 소스를 보니 의문점이 생겼어요.


```swift
class Foo { }

func bar() {
    let a = Foo()
}
```
위 코드를 SIL 로 컴파일하면 다음의 SIL 코드가 나와요.
```
...
// bar()
// Isolation: unspecified
sil hidden @$s1b3baryyF : $@convention(thin) () -> () {
bb0:
  %0 = metatype $@thick Foo.Type                  // user: %2
  // function_ref Foo.__allocating_init()
  %1 = function_ref @$s1b3FooCACycfC : $@convention(method) (@thick Foo.Type) -> @owned Foo // user: %2
  %2 = apply %1(%0) : $@convention(method) (@thick Foo.Type) -> @owned Foo // users: %4, %3
  debug_value %2 : $Foo, let, name "a"            // id: %3
  strong_release %2 : $Foo                        // id: %4
  %5 = tuple ()                                   // user: %6
  return %5 : $()                                 // id: %6
} // end sil function '$s1b3baryyF'
...
```

strong_release는 있는데 **왜 retain 관련 코드가 없지??**
그래서 ARC에 관해서 더 깊게 파헤쳐보기로 했어요.

## 2. ARC 동작 개요
ARC에 관해서는 짧게 설명할게요.

Swift의 ARC(Automatic Reference Counting)는 말 그대로 참조 카운트 기반으로 메모리를 자동 관리해주는 시스템이에요.
각 객체가 몇 번 참조되고 있는지 컴파일러가 알아서 추적해서, strong 참조가 모두 사라지는 순간 메모리를 정리해줘요.
ARC는 strong, weak, unowned 세 가지 참조 방식을 지원해요. 
weak은 참조 대상이 없어지면 자동으로 nil이 돼서 안전하게 사용할 수 있고, unowned는 참조 대상이 사라진 뒤에도 그대로 남아있다가, 그걸 다시 접근하면 런타임 크래시가 나기 때문에 생명주기가 명확할 때만 써야 해요.

## 3. Swift Runtime Heap Object 구조
사실 위 SIL 코드에 retain 관련 코드가 없는 이유는 쉽게 찾을 수 있었어요.
> The object has an initial retain count of 1 
> [swift/HeapObject.h](https://github.com/swiftlang/swift/blob/main/include/swift/Runtime/HeapObject.h#L45-L48)

> // Refcount of a new object is 1.
> constexpr RefCounts(Initialized_t) : refCounts(RefCountBits(0, 1)) { }
> [swift/RefCount.h](https://github.com/swiftlang/swift/blob/main/stdlib/public/SwiftShims/swift/shims/RefCount.h#L741-L742)

retain count의 초기값이 1이기 때문이었죠. 
아 그렇구나..! 하고서 끝내려는 참에 swift compiler의 소스코드를 보면서 재미있는 포인트를 몇개 더 찾았어요.

**Physical field is 0?**

> The strong RC is stored as an extra count: when the physical field is 0 the logical value is 1.
> [swift/RefCount.h](https://github.com/swiftlang/swift/blob/main/stdlib/public/SwiftShims/swift/shims/RefCount.h#L48-L51)

**Reference count가 3개?**

> An object conceptually has three refcounts. These refcounts
> are stored either "inline" in the field following the isa
> or in a "side table entry" pointed to by the field following the isa.
> [swift/RefCount.h](https://github.com/swiftlang/swift/blob/main/stdlib/public/SwiftShims/swift/shims/RefCount.h#L44-L46)

이 두가지에 의문이 생겨서 더 찾아보기로 했어요.

### 3-1. Physical field is 0
Swift 런타임에서 strong reference count는 실제 메모리에는 0부터 시작하지만, 논리적으로는 1로 동작해요.
즉, 객체가 생성될 때 내부 refcount 비트 값은 0이지만, Swift ARC는 이걸 “reference count 1”로 간주하는 거죠.

이게 무슨 말이냐면, 예를 들어 아래처럼 객체가 메모리에 올라오면 물리적으로는 0이지만 논리적으로는 1입니다.

```
+----------------------+
|    Heap Object       |
+----------------------+
| ...                  |
| RefCount bits:   0   |  ← 내부 비트값(0) = 참조 1개!
+----------------------+
```

**왜 이렇게 되어 있을까?**

처음에는 "왜 굳이 physical level과 logical level에서 차이가 나게 구현했을까?" 라는 의문이 생겼어요.

이렇게 설계된 이유는 underflow만 감지하면 deinit이 가능하기 때문이에요.
즉, 참조 카운트가 1에서 0으로 감소할 때를 따로 체크하지 않고,
비트 값이 음수가 되는 순간(underflow)만 잡아서 객체 해제를 트리거하면 충분하다는 거죠.

또한 physical level에서 1로 저장하는 것보다 0으로 저장하는게 더 빠를 가능성이 높아요.
아래 코드의 `return ` 부분을 보면 `SignedBitsType >= 0` 이라는 부분이 있는데 MSB 하나만 보면
bits가 음수인지 0이상인지 바로 알 수 있기 때문이에요.

```cpp
decrementStrongExtraRefCount(uint32_t dec) {
  ...
  bits -= BitsType(dec) << Offsets::StrongExtraRefCountShift;
  return (SignedBitsType(bits) >= 0);
}
```
[swift/RefCount.h](https://github.com/swiftlang/swift/blob/main/stdlib/public/SwiftShims/swift/shims/RefCount.h#L571)

### 3-2. Reference Count가 3개?

Swift ARC는 단순히 strong 참조만 관리하는 게 아니라, strong, unowned, weak 세 가지 카운트를 각각 독립적으로 관리하고 있어요.
이 부분은 [swift/RefCount.h](https://github.com/swiftlang/swift/blob/main/stdlib/public/SwiftShims/swift/shims/RefCount.h#L571) 소스 코드 상단 주석에서 아주 명확하게 확인할 수 있어요.

```
An object conceptually has three refcounts. These refcounts
are stored either “inline” in the field following the isa
or in a “side table entry” pointed to by the field following the isa.
```



**Strong Reference Count**
-	객체가 살아있는 동안 실제로 메모리 소유권을 가지는 참조 개수예요.
-	strong RC가 0이 되는 순간, deinit이 호출돼요.

**Unowned Reference Count**
-	unowned 참조의 개수를 셉니다.
-	중요한 점은, strong 참조가 남아있을 때는 unowned RC에도 +1 더해져 있다는 점이에요.
-	deinit이 끝나면 unowned RC에서 -1을 하고, unowned RC가 0이 될 때 진짜 메모리 해제(deallocation)가 일어나요.
-	unowned 참조는 weak과 다르게 참조 대상이 사라진 후 접근하면 크래시가 발생해요.

**Weak Reference Count**
-	weak 참조의 개수를 셉니다.
- 객체가 deinit되면	weak 참조 변수 쪽에 nil이 할당되요.
- weak RC가 0이 되면 side table 메모리까지 완전히 해제돼요.


